variableNames = colnames(data[[1]]),
verbose = TRUE,
nLambda = 50,
gimmeGVARThreshold = .5,
gammaValue = 0)
source("~/Dropbox/GitHub/GIMMEgVAR/R/03_fitGIMMEgVAR.R", echo=TRUE)
source("~/Dropbox/GitHub/GIMMEgVAR/R/02_prepareGIMMEgVARData.R", echo=TRUE)
source("~/Dropbox/GitHub/GIMMEgVAR/R/03_fitGIMMEgVAR.R", echo=TRUE)
source("~/Dropbox/GitHub/GIMMEgVAR/R/01_fitGraphicalVAR.R", echo=TRUE)
source("~/Dropbox/GitHub/GIMMEgVAR/R/00_enviornmentSetup.R", echo=TRUE)
source("~/Dropbox/GitHub/GIMMEgVAR/R/GIMMEgVAR.R", echo=TRUE)
load("~/Dropbox/GitHub/gimme/gimme/data/ts.rda")
data <- ts[1:2]
GIMMEgVAR(outputPath = "~/Desktop/trial2",
data = data,
variableNames = colnames(data[[1]]),
verbose = TRUE,
nLambda = 50,
gimmeGVARThreshold = .5,
gammaValue = 0)
source("~/Dropbox/GitHub/GIMMEgVAR/R/02_prepareGIMMEgVARData.R", echo=TRUE)
GIMMEgVAR(outputPath = "~/Desktop/trial2",
data = data,
variableNames = colnames(data[[1]]),
verbose = TRUE,
nLambda = 50,
gimmeGVARThreshold = .5,
gammaValue = 0)
RES_groupBeta
pathProportionBeta
RES_groupKappa
pathProportionKappa
source("~/Dropbox/GitHub/GIMMEgVAR/R/01_fitGraphicalVAR.R", echo=TRUE)
source("~/Dropbox/GitHub/GIMMEgVAR/R/03_fitGIMMEgVAR.R", echo=TRUE)
source("~/Dropbox/GitHub/GIMMEgVAR/R/03_fitGIMMEgVAR.R", echo=TRUE)
load("~/Dropbox/GitHub/gimme/gimme/data/ts.rda")
data <- ts[1:2]
#CALL GIMMEgVAR
GIMMEgVAR(outputPath = "~/Desktop/trial2",
data = data,
variableNames = colnames(data[[1]]),
verbose = TRUE,
nLambda = 50,
gimmeGVARThreshold = .5,
gammaValue = 0)
source("~/Dropbox/GitHub/GIMMEgVAR/R/GIMMEgVAR.R", echo=TRUE)
source("~/Dropbox/GitHub/GIMMEgVAR/R/00_enviornmentSetup.R", echo=TRUE)
source("~/Dropbox/GitHub/GIMMEgVAR/R/01_fitGraphicalVAR.R", echo=TRUE)
source("~/Dropbox/GitHub/GIMMEgVAR/R/02_prepareGIMMEgVARData.R", echo=TRUE)
source("~/Dropbox/GitHub/GIMMEgVAR/R/03_fitGIMMEgVAR.R", echo=TRUE)
load("~/Dropbox/GitHub/gimme/gimme/data/ts.rda")
data <- ts[1:2]
#CALL GIMMEgVAR
GIMMEgVAR(outputPath = "~/Desktop/trial2",
data = data,
variableNames = colnames(data[[1]]),
verbose = TRUE,
nLambda = 50,
gimmeGVARThreshold = .5,
gammaValue = 0)
source("~/Dropbox/GitHub/GIMMEgVAR/R/03_fitGIMMEgVAR.R", echo=TRUE)
load("~/Dropbox/GitHub/gimme/gimme/data/ts.rda")
data <- ts[1:2]
#CALL GIMMEgVAR
GIMMEgVAR(outputPath = "~/Desktop/trial2",
data = data,
variableNames = colnames(data[[1]]),
verbose = TRUE,
nLambda = 50,
gimmeGVARThreshold = .5,
gammaValue = 0)
load("~/Dropbox/GitHub/gimme/gimme/data/ts.rda")
data <- ts[1:2]
#CALL GIMMEgVAR
output <- GIMMEgVAR(outputPath = "~/Desktop/trial2",
data = data,
variableNames = colnames(data[[1]]),
verbose = TRUE,
nLambda = 50,
gimmeGVARThreshold = .5,
gammaValue = 0)
rm(pathCountBeta, pathCountKappa, pathProportionBeta, pathProportionKappa, RES_matrixData, resultsGIMMEgvar)
source("~/Dropbox/GitHub/GIMMEgVAR/R/03_fitGIMMEgVAR.R", echo=TRUE)
rm(pathCountBeta, pathCountKappa, pathProportionBeta, pathProportionKappa, RES_matrixData, resultsGIMMEgVAR)
rm(pathCountBeta, pathCountKappa, pathProportionBeta, pathProportionKappa, RES_matrixData, resultsGIMMEgVAR, logicalBeta, logicalKappa, RES_groupBeta, RES_groupKappa)
source("~/Dropbox/GitHub/GIMMEgVAR/R/03_fitGIMMEgVAR.R", echo=TRUE)
source("~/Dropbox/GitHub/GIMMEgVAR/R/03_fitGIMMEgVAR.R", echo=TRUE)
load("~/Dropbox/GitHub/gimme/gimme/data/ts.rda")
data <- ts[1:2]
#CALL GIMMEgVAR
output <- GIMMEgVAR(outputPath = "~/Desktop/trial2",
data = data,
variableNames = colnames(data[[1]]),
verbose = TRUE,
nLambda = 50,
gimmeGVARThreshold = .5,
gammaValue = 0)
currentenv()
current_env()
globalenv()
currentenv()
env.profile()
env.profile(current)
env.profile("current")
set.seed(1234)
library(dplyr)
library(lme4)
library(tidyverse)
# If test = TRUE, will only create one data frame to look at, else test = FALSE
test = FALSE
# If effect_hetero = TRUE, will simulate half data with negative "coeff"
effect_hetero = TRUE
# Number of conditions
cases <- c(1:1)
# Number of trials
trials <- 500
# Timepoints
t <- c(200, 10, 200, 10, 90, 200)
# People
n <- c(100, 5, 50, 50, 50, 50)
#coeff for AR vector
coeff = 0.5
# Distribution mean & stand dev of error
mu_e <- c(0, 0, 0, 0, 0, 0)
sd_e <- c(1, 1, 1, 1, 1, 1)
# Distribution mean & stand dev of latent factor (y_t-1)
mu_a <- c(0, 0, 0, 0, 0, 0)
test
test = FALSE
test = TRUE
c <- 1
# Creates t X n error matrix
e <- mvtnorm::rmvnorm(t[c], mean = rep(mu_e[c],n[c]), sigma = diag(sd_e[c], ncol = n[c], nrow = n[c]))
e <- data.matrix(e)
# Initialized at mean value
# Label y columns with participant #s
y <- matrix(mu_a[c], nrow = t[c], ncol = n[c])
colnames(y) <- as.character(seq(1,n[c],1))
# Initialize Normal, random data for t = 1
y[1, ] <- rep(mu_a[c],n[c])
# Calc Lag 1 data
for (i in 2:nrow(y)) {
y[i, ] <- coeff * y[i-1,] + e[i, ]
}
dim(y)
ts.plot(y[,1])
ts.plot(y[,3])
colnames(y) <- as.character(seq(1,n[c],1))
colnames(y)
y[1, ] <- rep(mu_a[c],n[c])
dim(e)
n[c]
mu_e[c]
t[c]
# use case 1 values
c <- 1
# Creates t X n error matrix
e <- mvtnorm::rmvnorm((t[c]+burnin), mean = rep(mu_e[c],n[c]), sigma = diag(sd_e[c], ncol = n[c], nrow = n[c]))
burnin <- 400
# Creates t X n error matrix
e <- mvtnorm::rmvnorm((t[c]+burnin), mean = rep(mu_e[c],n[c]), sigma = diag(sd_e[c], ncol = n[c], nrow = n[c]))
e <- data.matrix(e)
y <- matrix(mu_a[c], nrow = (t[c]+burnin), ncol = n[c])
colnames(y) <- as.character(seq(1,n[c],1))
y[1, ] <- rep(mu_a[c],n[c])
for (i in 2:nrow(y)) {
y[i, ] <- coeff * y[i-1,] + e[i, ]
}
y <- y[burnin:length(y[,1]),]
dim(y)
y <- y[(burnin+1):length(y[,1]),]
y <- y[(burnin+1):length(y[,1]),]
ialized at mean value
# Initialized at mean value
# Label y columns with participant #s
y <- matrix(mu_a[c], nrow = (t[c]+burnin), ncol = n[c])
colnames(y) <- as.character(seq(1,n[c],1))
# Initialize Normal, random data for t = 1
y[1, ] <- rep(mu_a[c],n[c])
# Calc Lag 1 data
for (i in 2:nrow(y)) {
y[i, ] <- coeff * y[i-1,] + e[i, ]
}
y <- y[(burnin+1):length(y[,1]),]
dim(y)
plot(y[,1])
ts.plot(y[,1])
participant_ids <- c()
participant_ids <- append(rep(1:n[c], each = t[c]), participant_ids)
# generate timepoints
timepoints <- c()
timepoints <- append(rep(1:t[c], times = n[c]), timepoints)
outcome <- c()
for (n in n[c]){
outcome <- append(y[,n], outcome)
}
fake_data <- data.frame(ParticipantID = participant_ids, Timepoint = timepoints, Outcome = outcome)
multilevel_model <- lmer(Outcome ~ Timepoint + (1 + Timepoint| ParticipantID),
data = fake_data,
control = lmerControl(optCtrl = list(maxfun = 10000)))
output <- summary(multilevel_model)
mlm_coeff_dat[1,] <- output$coefficients["Timepoint","Estimate"]
test
library(stats)
arFit <- list()
for (p in 1:n[c])
arFit[[p]] <- ar(y[,p])
arFit[[1]]$order
order <- matrix(, ncol= n[c])
lagOrder <- matrix(, ncol= n[c])
lag1est  <- matrix(,ncol = n[c])
arFit[[1]]$ar
ttt <- unlist(arFit)
View(ttt)
require("plyr")
View(ttt)
ttt$ar
for (p in 1:n[c]){
arFit[[p]] <- ar(y[,p])
lagOrder[p] <- arFit[[p]]$order
lag1est[p]  <- arFit[[p]]$ar
}
warnings()
hist(lagOrder)
count(which(lagOrder == 1))
sum(which(lagOrder == 1))
View(lagOrder)
which(lagOrder ==1)
length(which(lagOrder ==1))
for (p in 1:n[c]){
arFit[[p]] <- ar(y[,p])
lagOrder[p] <- arFit[[p]]$order
lag1est[p]  <- arFit[[p]]$ar[1]
}
mean(lag1est[p])
participant_ids <- c()
participant_ids <- append(rep(1:n[c], each = t[c]), participant_ids)
# generate timepoints
timepoints <- c()
timepoints <- append(rep(1:t[c], times = n[c]), timepoints)
outcome <- c()
for (n in n[c]){
outcome <- append(y[,n], outcome)
}
View(outcome)
View(outcome)
# generate participant_ids
participant_ids <- c()
participant_ids <- append(rep(1:n[c], each = t[c]), participant_ids)
participant_ids
# generate timepoints
timepoints <- c()
timepoints <- append(rep(1:t[c], times = n[c]), timepoints)
outcome <- c()
for (n in n[c]){
outcome <- append(y[,n], outcome)
}
fake_data <- data.frame(ParticipantID = participant_ids, Timepoint = timepoints, Outcome = outcome)
View(fake_data)
timepoints
all_cond_mlm_coeff <- matrix(nrow = length(cases), ncol = 1) %>% data.frame() %>% setNames(c("Condition Lag Coeff"))
all_cond_ar_coeff <- c()
all_cond_ar_order <- c()
c
trial_coeffs <- matrix(nrow = trials, ncol = 1) %>% data.frame() %>% setNames(c("Lag Coeff"))
trial_ar_coeff <- c()
trial_ar_order <- c()
# Creates t X n error matrix
e <- mvtnorm::rmvnorm(t[c], mean = rep(mu_e[c],n[c]), sigma = diag(sd_e[c], ncol = n[c], nrow = n[c]))
e <- data.matrix(e)
# Creates t X n error matrix
e <- mvtnorm::rmvnorm((t[c]+burnin), mean = rep(mu_e[c],n[c]), sigma = diag(sd_e[c], ncol = n[c], nrow = n[c]))
e <- data.matrix(e)
# Initialized at mean value
y <- matrix(mu_a[c], nrow = (t[c]+burnin), ncol = n[c])
colnames(y) <- as.character(seq(1,n[c],1))
y[1, ] <- rep(mu_a[c],n[c])
for (i in 2:nrow(y)) {
# Multiply first half of participant values by -1 to simulate effects heterogeneity (ex: -0.5 coeff)
if (i < ceiling(0.5*n[c])){
y[i, ] <- -1 * coeff * y[i-1,] + e[i, ]}
else {
y[i, ] <- coeff * y[i-1,] + e[i, ]}}
}
if (effect_hetero == TRUE){
for (i in 2:nrow(y)) {
# Multiply first half of participant values by -1 to simulate effects heterogeneity (ex: -0.5 coeff)
if (i < ceiling(0.5*n[c])){
y[i, ] <- -1 * coeff * y[i-1,] + e[i, ]}
else {
y[i, ] <- coeff * y[i-1,] + e[i, ]}}
}
effect_hetero
for (ind in 1:n[c]){
fitAR <- ar(y[,ind])
trial_ar_coeff <- append(trial_ar_coeff, fitAR$ar[1])
trial_ar_order <- append(trial_ar_order, fitAR$order)
}
mean(trial_ar_coeff)
mean(trial_ar_order)
trial_ar_coeff <- c()
trial_ar_order <- c()
# Creates t X n error matrix
e <- mvtnorm::rmvnorm((t[c]+burnin), mean = rep(mu_e[c],n[c]), sigma = diag(sd_e[c], ncol = n[c], nrow = n[c]))
e <- data.matrix(e)
max(cor(e))
dd <- cor(e)
diag(dd) <- 0
max(cor(e))
View(cor(e))
max(cor(dd))
View(dd)
which(dd == 1)
max(dd)
e <- matrix(data = rnorm(n = ((t[c]+burnin)*n[c]), mean = 0, var = 1), nrow = (t[c]*burnin), ncol = n[c])
e <- matrix(data = rnorm(n = ((t[c]+burnin)*n[c]), mean = 0, st = 1), nrow = (t[c]*burnin), ncol = n[c])
e <- matrix(data = rnorm(n = ((t[c]+burnin)*n[c]), mean = 0, std = 1), nrow = (t[c]*burnin), ncol = n[c])
?? rnorm
? rnorm
e <- matrix(data = rnorm(n = ((t[c]+burnin)*n[c]), mean = 0, sd = 1), nrow = (t[c]*burnin), ncol = n[c])
((t[c]+burnin)*n[c])
e <- matrix(data = rnorm(n = ((t[c]+burnin)*n[c]), mean = 0, sd = 1), nrow = (t[c]+burnin), ncol = n[c])
y <- matrix(mu_a[c], nrow = (t[c]+burnin), ncol = n[c])
colnames(y) <- as.character(seq(1,n[c],1))
y[1, ] <- rep(mu_a[c],n[c])
if (effect_hetero == TRUE){
for (i in 2:nrow(y)) {
# Multiply first half of participant values by -1 to simulate effects heterogeneity (ex: -0.5 coeff)
if (i < ceiling(0.5*n[c])){
y[i, ] <- -1 * coeff * y[i-1,] + e[i, ]}
else {
y[i, ] <- coeff * y[i-1,] + e[i, ]}}
}
else{
for (ind in 1:n[c]){
fitAR <- ar(y[,ind])
trial_ar_coeff <- append(trial_ar_coeff, fitAR$ar[1])
trial_ar_order <- append(trial_ar_order, fitAR$order)
}
mean(trial_ar_order)
mean(trial_ar_coeff)
hist(trial_ar_coeff)
-1 * coeff
1 * coeff * y[i-1,]
if (effect_hetero == TRUE){
for (i in 2:nrow(y)) {
# Multiply first half of participant values by -1 to simulate effects heterogeneity (ex: -0.5 coeff)
if (i < ceiling(0.5*n[c])){
y[i, ] <- (-1 * coeff) * y[i-1,] + e[i, ]}
else {
y[i, ] <- coeff * y[i-1,] + e[i, ]}}
}
# Enter AR function here
for (ind in 1:n[c]){
fitAR <- ar(y[,ind])
trial_ar_coeff <- append(trial_ar_coeff, fitAR$ar[1])
trial_ar_order <- append(trial_ar_order, fitAR$order)
}
hist(trial_ar_coeff)
hist(trial_ar_coeff)
mean(trial_ar_coeff)
if (effect_hetero == TRUE){
for (i in 2:nrow(y)) {
# Multiply first half of participant values by -1 to simulate effects heterogeneity (ex: -0.5 coeff)
# kmg - this was actually multiplying the first half of observations by -.5, and the second half by 0.5.
# this is because rows are time points; participants are collumns
# if (i < ceiling(0.5*n[c])){
#   y[i, ] <- (-1 * coeff) * y[i-1,] + e[i, ]}
for (ind in 1:(ceiling(0.5*n[c])))
y[i, ind] <- (-1 * coeff) * y[i-1,ind] + e[i,ind ]
for (ind in ((ceiling(0.5*n[c])+1):n[c]))
y[i, ind] <- coeff * y[i-1,ind] + e[i,ind ]}
else {
if (effect_hetero == TRUE){
for (i in 2:nrow(y)) {
# Multiply first half of participant values by -1 to simulate effects heterogeneity (ex: -0.5 coeff)
# kmg - this was actually multiplying the first half of observations by -.5, and the second half by 0.5.
# this is because rows are time points; participants are collumns
# if (i < ceiling(0.5*n[c])){
#   y[i, ] <- (-1 * coeff) * y[i-1,] + e[i, ]}
for (ind in 1:(ceiling(0.5*n[c])))
y[i, ind] <- (-1 * coeff) * y[i-1,ind] + e[i,ind ]
for (ind in ((ceiling(0.5*n[c])+1):n[c]))
y[i, ind] <- coeff * y[i-1,ind] + e[i,ind ]
}
}
# Enter AR function here
for (ind in 1:n[c]){
fitAR <- ar(y[,ind])
trial_ar_coeff <- append(trial_ar_coeff, fitAR$ar[1])
trial_ar_order <- append(trial_ar_order, fitAR$order)
}
hist(trial_ar_order)
hist(trial_ar_coeff)
(ceiling(0.5*n[c]))
length((ceiling(0.5*n[c])+1):n[c]))
length((ceiling(0.5*n[c])+1):n[c])
View(trial_ar_order)
plot(trial_ar_order)
n[c]
ind
length(trial_ar_order)
trial_ar_coeff <- c()
trial_ar_order <- c()
# Creates t X n error matrix
# e <- mvtnorm::rmvnorm((t[c]+burnin), mean = rep(mu_e[c],n[c]), sigma = diag(sd_e[c], ncol = n[c], nrow = n[c]))
# e <- data.matrix(e)
e <- matrix(data = rnorm(n = ((t[c]+burnin)*n[c]), mean = 0, sd = 1), nrow = (t[c]+burnin), ncol = n[c])
# Initialized at mean value
y <- matrix(mu_a[c], nrow = (t[c]+burnin), ncol = n[c])
# Label y columns with participant #s
colnames(y) <- as.character(seq(1,n[c],1))
# Initialize normal, random data for t = 1
y[1, ] <- rep(mu_a[c],n[c])
if (effect_hetero == TRUE){
for (i in 2:nrow(y)) {
# Multiply first half of participant values by -1 to simulate effects heterogeneity (ex: -0.5 coeff)
# kmg - this was actually multiplying the first half of observations by -.5, and the second half by 0.5.
# this is because rows are time points; participants are collumns
# if (i < ceiling(0.5*n[c])){
#   y[i, ] <- (-1 * coeff) * y[i-1,] + e[i, ]}
for (ind in 1:(ceiling(0.5*n[c])))
y[i, ind] <- (-1 * coeff) * y[i-1,ind] + e[i,ind ]
for (ind in ((ceiling(0.5*n[c])+1):n[c]))
y[i, ind] <- coeff * y[i-1,ind] + e[i,ind ]
}
}
else{
if (effect_hetero == TRUE){
for (i in 2:nrow(y)) {
# Multiply first half of participant values by -1 to simulate effects heterogeneity (ex: -0.5 coeff)
# kmg - this was actually multiplying the first half of observations by -.5, and the second half by 0.5.
# this is because rows are time points; participants are collumns
# if (i < ceiling(0.5*n[c])){
#   y[i, ] <- (-1 * coeff) * y[i-1,] + e[i, ]}
for (ind in 1:(ceiling(0.5*n[c])))
y[i, ind] <- (-1 * coeff) * y[i-1,ind] + e[i,ind ]
for (ind in ((ceiling(0.5*n[c])+1):n[c]))
y[i, ind] <- coeff * y[i-1,ind] + e[i,ind ]
}
} else{
for (i in 2:nrow(y)) {
y[i, ] <- coeff * y[i-1,] + e[i, ] }}
# Enter AR function here
for (ind in 1:n[c]){
fitAR <- ar(y[,ind])
trial_ar_coeff <- append(trial_ar_coeff, fitAR$ar[1])
trial_ar_order <- append(trial_ar_order, fitAR$order)
}
hist(trial_ar_order)
hist(trial_ar_coeff)
timepoints <- c()
timepoints <- append(rep(1:t[c], times = n[c]), timepoints)
dim(timepoints)
length(timepoitns)
length(timepoints)
library(testthat)
library(gimme)
test_check("gimme")
test_that("Run 1 gives expected results", {
run1_sot <- readRDS("rds/run1_path_matrix.rds")
run1_paths_sot <-readRDS("rds/run1_path_counts.rds")
run1 <- gimme(data = gimme::ts)
expect_equal(run1[["path_est_mats"]], run1_sot, tolerance = 1e-5)
expect_identical(run1[["path_counts"]], run1_paths_sot)
})
test_that("Run 2 gives expected results", {
run2_sot <- readRDS("rds/run2_path_matrix.rds")
run2_paths_sot <-readRDS("rds/run2_path_counts.rds")
run2 <- gimme(data = gimme::HRFsim,
ar = TRUE,
exogenous = "V5",
conv_vars = "V5",
conv_length = 16,
conv_interval = 1,
mult_vars = "V4*V5",
mean_center_mult = TRUE
)
expect_equal(run2[["path_est_mats"]], run2_sot, tolerance = 1e-5)
expect_identical(run2[["path_counts"]], run2_paths_sot)
})
setwd("~/Dropbox/GitHub/gimme/gimme/tests/testthat")
test_that("Run 1 gives expected results", {
run1_sot <- readRDS("rds/run1_path_matrix.rds")
run1_paths_sot <-readRDS("rds/run1_path_counts.rds")
run1 <- gimme(data = gimme::ts)
expect_equal(run1[["path_est_mats"]], run1_sot, tolerance = 1e-5)
expect_identical(run1[["path_counts"]], run1_paths_sot)
})
test_that("Run 2 gives expected results", {
run2_sot <- readRDS("rds/run2_path_matrix.rds")
run2_paths_sot <-readRDS("rds/run2_path_counts.rds")
run2 <- gimme(data = gimme::HRFsim,
ar = TRUE,
exogenous = "V5",
conv_vars = "V5",
conv_length = 16,
conv_interval = 1,
mult_vars = "V4*V5",
mean_center_mult = TRUE
)
expect_equal(run2[["path_est_mats"]], run2_sot, tolerance = 1e-5)
expect_identical(run2[["path_counts"]], run2_paths_sot)
})
test_that("Run 3 gives expected results", {
run3_sot <- readRDS("rds/run3_path_matrix.rds")
run3_paths_sot <-readRDS("rds/run3_path_counts.rds")
run3 <- gimme(data = gimme::simData,
subgroup = TRUE)
expect_equal(run3[["path_est_mats"]], run3_sot, tolerance = 1e-5)
expect_identical(run3[["path_counts"]], run3_paths_sot)
})
