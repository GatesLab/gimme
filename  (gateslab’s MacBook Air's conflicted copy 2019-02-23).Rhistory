elig_paths   = dat$candidate_paths,
confirm_subgroup = confirm_subgroup,
out_path     = dat$out,
sub_feature  = sub_feature)
sub_membership  = NULL # appease CRAN check
sub     <- list()
z_list  <- list()
mi_list <- list()
converge <- matrix(,n_subj,1)
for (k in 1:n_subj){
writeLines(paste0("subgroup search, subject ", k, " (",names(data_list)[k],")"))
fit          <- fit.model(syntax    = base_syntax,
data_file = data_list[[k]])
z_list[[k]]  <- return.zs(fit)
mi_list[[k]] <- return.mis(fit)
converge[k]  <- lavInspect(fit, "converged")
}
names(z_list) <- names(mi_list) <- names(data_list)
drop <- which(converge==FALSE)
if (length(drop) != 0){
mi_list <- mi_list[-drop]
z_list  <- z_list[-drop]
}
mi_list_temp <- lapply(mi_list,
function(x){x$param <- paste0(x$lhs, x$op, x$rhs)
x$sig   <- ifelse(x$mi > chisq_cutoff, 1, 0)
return(x)})
mi_list <- lapply(mi_list_temp,
function(x){subset(x, x$param %in% elig_paths)})
if (length(which(is.na(z_list)))==0)
z_list <- lapply(z_list,
function(x){x$sig <- ifelse(x$p < .05/n_subj, 1, 0)
return(x)})
if(sub_feature == "contemp"){
mi_list <- lapply(mi_list,
function(x){x[-grep('lag',mi_list[[1]]$rhs),]})
z_list <- lapply(z_list,
function(x){x[-grep('lag',z_list[[1]]$rhs),]})
}
if(sub_feature == "lagged"){
mi_list <- lapply(mi_list,
function(x){x[grep('lag',mi_list[[1]]$rhs),]})
z_list <- lapply(z_list,
function(x){x[grep('lag',z_list[[1]]$rhs),]})
}
sim_mi <- matrix(0, ncol = length(mi_list), nrow = length(mi_list))
sim_z  <- sim_mi
for (i in 1:length(mi_list)){
for (j in 1:length(mi_list)){
sim_mi[i,j] <- sum(mi_list[[i]]$sig == 1 & mi_list[[j]]$sig == 1 &
sign(mi_list[[i]]$epc) == sign(mi_list[[j]]$epc), na.rm = TRUE)
sim_z[i,j]  <- sum(z_list[[i]]$sig == 1 & z_list[[j]]$sig == 1 &
sign(z_list[[i]]$z) == sign(z_list[[j]]$z), na.rm = TRUE)
}
}
sim_z[i,j]  <- sum(z_list[[i]]$sig == 1 & z_list[[j]]$sig == 1 &
sign(z_list[[i]]$z) == sign(z_list[[j]]$z), na.rm = TRUE)
z_list[[1]]
length(which(is.na(z_list)))==0
for (i in 1:length(mi_list)){
for (j in 1:length(mi_list)){
sim_mi[i,j] <- sum(mi_list[[i]]$sig == 1 & mi_list[[j]]$sig == 1 &
sign(mi_list[[i]]$epc) == sign(mi_list[[j]]$epc), na.rm = TRUE)
if (length(which(is.na(z_list)))==0)
sim_z[i,j]  <- sum(z_list[[i]]$sig == 1 & z_list[[j]]$sig == 1 &
sign(z_list[[i]]$z) == sign(z_list[[j]]$z), na.rm = TRUE)
}
}
sim           <- sim_mi + sim_z
sim           <- sim - min(sim, na.rm = TRUE)
diag(sim)     <- 0
colnames(sim) <- rownames(sim) <- names(mi_list)
if(is.null(confirm_subgroup)){
res        <- walktrap.community(graph.adjacency(sim, mode = "undirected"),
steps = 4)
sub_mem    <- data.frame(names      = names(membership(res)),
sub_membership = as.numeric(membership(res)))
sub$sim         <- sim
sub$n_subgroups <- length(unique(na.omit(sub_mem$sub_membership)))
sub$modularity  <- modularity(res)
sub$sub_mem     <- merge(file_order, sub_mem, by = "names", all.x = TRUE)
} else {
sub_mem         <- confirm_subgroup
names(sub_mem)  <- c("names", "sub_membership")
sub$sim         <- sim
sub$n_subgroups <- length(unique(na.omit(sub_mem$sub_membership)))
sub$sub_mem     <- merge(file_order, sub_mem, by = "names", all.x = TRUE)
sub$modularity  <- modularity(graph.adjacency(sim, mode = "undirected"), (sub$sub_mem)$sub_membership)
}
library(gimme)
gimmeSEM(data     = "~/Downloads/gimme_Exog_test/Test_Input",
out      = "~/Downloads/gimme_Exog_test/Test_Output",
sep      = ",",
header   = F,
ar       = F,
subgroup = T,
exogenous = c("V3", "V4"))
library(igraph)
library(R.utils)
library(qgraph)
library(mcclust)
library(lavaan)
sourceDirectory("/Users/gateslab/Dropbox/GitHub/gimme/gimme/R")
#Set defaults
# data          = dataBlog
out            = NULL
sep            = NULL
header         = NULL
ar             = TRUE
plot           = TRUE
subgroup       = FALSE
confirm_subgroup = NULL
paths          = NULL
# "V2~V1+V5lag"
#                  "V3~V2"
#                  "V4 ~ V3byV5lag"
standardize    = TRUE
exogenous      = NULL
conv_vars      = NULL
conv_length    = 16
conv_intervals = 1
groupcutoff    = .75
subcutoff      = .5
diagnos        = FALSE
ind            = FALSE
agg            = FALSE
sub_feature    = "lag & contemp"
ex_lag         = TRUE
mult_vars      = NULL
mean_center_mult = TRUE
conv_vars   = NULL
conv_length = 16
conv_interval = 1
mult_vars   = NULL
mean_center_mult = FALSE
ms_allow         = FALSE
ms_tol           = 1e-5
## for setup
ind                  = FALSE
agg                  = FALSE
lv_scores        = "regression"
lv_estimator     = "miiv"
lv_miiv_scaling  = "first.indicator"
lv_final_estimator = "miiv"
lv_model = NULL
# search.paths
grp
subgroupStage(
dat,
grp[[i]],
confirm_subgroup,
sub_feature,
ms_tol   = ms_tol,
ms_allow = FALSE''
subgroupStage(
dat,
grp[[i]],
confirm_subgroup,
sub_feature,
ms_tol   = ms_tol,
ms_allow = FALSE
)
res <- subgroupStage(
dat,
grp[[i]],
confirm_subgroup,
sub_feature,
ms_tol   = ms_tol,
ms_allow = FALSE
)
library(igraph)
library(R.utils)
library(qgraph)
library(mcclust)
library(lavaan)
library(igraph)
library(R.utils)
library(qgraph)
library(mcclust)
library(lavaan)
sourceDirectory("/Users/gateslab/Dropbox/GitHub/gimme/gimme/R")
out            = NULL
sep            = NULL
header         = NULL
ar             = TRUE
plot           = TRUE
subgroup       = FALSE
confirm_subgroup = NULL
paths          = NULL
# "V2~V1+V5lag"
#                  "V3~V2"
#                  "V4 ~ V3byV5lag"
standardize    = TRUE
exogenous      = NULL
conv_vars      = NULL
conv_length    = 16
conv_intervals = 1
groupcutoff    = .75
subcutoff      = .5
diagnos        = FALSE
ind            = FALSE
agg            = FALSE
sub_feature    = "lag & contemp"
ex_lag         = TRUE
mult_vars      = NULL
mean_center_mult = TRUE
conv_vars   = NULL
conv_length = 16
conv_interval = 1
mult_vars   = NULL
mean_center_mult = FALSE
ms_allow         = FALSE
ms_tol           = 1e-5
## for setup
ind                  = FALSE
agg                  = FALSE
lv_scores        = "regression"
lv_estimator     = "miiv"
lv_miiv_scaling  = "first.indicator"
lv_final_estimator = "miiv"
lv_model = NULL
data     = "~/Downloads/gimme_Exog_test/Test_Input"
out      = "~/Downloads/gimme_Exog_test/Test_Output"
sep      = ","
header   = F
ar       = F
subgroup = T
exogenous = c("V3", "V4")
ind     = NULL
varnames = NULL
lvarnames = NULL
sub_membership = NULL
setupConvolve = NULL
ts = NULL
setupFinalDataChecks = NULL
if(ms_allow & subgroup){
stop(paste0("gimme ERROR: Subgrouping is not available for ms-gimme.",
" Please ensure that subgroup=FALSE if ms_allow=TRUE"))
}
if(ms_allow & ar){
writeLines("gimme WARNING: Multiple solutions not likely when ar=TRUE.",
" We recommend setting ar to FALSE.")
}
sub_membership = NULL
dat         <- setup(data                 = data,
sep                  = sep,
header               = header,
out                  = out,
plot                 = plot,
ar                   = ar,
paths                = paths,
exogenous            = exogenous,
mult_vars            = mult_vars,
mean_center_mult     = mean_center_mult,
standardize          = standardize,
subgroup             = subgroup,
ind                  = FALSE,
agg                  = FALSE,
groupcutoff          = groupcutoff,
subcutoff            = subcutoff,
conv_vars            = conv_vars,
conv_length          = conv_length,
conv_interval        = conv_interval,
lv_model             = lv_model,
lv_estimator         = lv_estimator,
lv_scores            = lv_scores,
lv_miiv_scaling      = lv_miiv_scaling)
if(subgroup & !is.null(confirm_subgroup)){
if(dim(confirm_subgroup)[[2]] != 2){
stop(paste0("gimme ERROR: confirmatory subgroup dataframe is not a two column dataframe.",
" Please ensure that the confirmatory subgroup dataframe consists of a column of filenames and a column of community assignments."))
}
if(length(match(confirm_subgroup[,1], (dat$file_order)$names)) != dim(confirm_subgroup)[[1]]){
stop(paste0("gimme ERROR: confirmatory subgroup dataframe contains mismatched filenames.",
" Please ensure that the confirmatory subgroup filenames match the data filenames, sans extensions (Example: sub_1000, not sub_1000.csv)"))
}
if(!is.numeric(confirm_subgroup[,2])){
stop(paste0("gimme ERROR: confirmatory subgroup assignments are non-numeric.",
" Please ensure that the confirmatory subgroup assignments are integer valued, beginning from 1. (Example: 1, 2, 3, 4)"))
}
}
grp <- list(
"n_group_paths" = 0,
"n_fixed_paths" = length(dat$fixed_paths),
"group_paths"   = c()
)
grp_hist  <- search.paths(
base_syntax    = dat$syntax,
fixed_syntax   = NULL,
add_syntax     = grp$group_paths,
n_paths        = grp$n_group_paths,
data_list      = dat$ts_list,
elig_paths     = dat$candidate_paths,
prop_cutoff    = dat$group_cutoff,
n_subj         = dat$n_subj,
chisq_cutoff   = qchisq(1-.05/dat$n_subj, 1),
subgroup_stage = FALSE,
ms_allow       = ms_allow,
ms_tol         = ms_tol
)
grp <- replicate(length(grp_hist[[length(grp_hist)]]), grp, simplify = FALSE)
grp <- lapply(seq_along(grp), function(i){
grp[[i]]$n_group_paths <- grp_hist[[length(grp_hist)]][[i]]$n_paths
grp[[i]]$group_paths   <- grp_hist[[length(grp_hist)]][[i]]$add_syntax
grp[[i]]
})
grp_hist <- lapply(seq_along(grp_hist), function(i){
lapply(seq_along(grp_hist[[i]]), function(j){
grp_hist[[i]][[j]]$pruned     <- NA
grp_hist[[i]][[j]]$stage      <- "group"
grp_hist[[i]][[j]]$grp_sol    <- NA
grp_hist[[i]][[j]]$sub_sol    <- NA
grp_hist[[i]][[j]]$ind_sol    <- NA
if(i == length(grp_hist[[length(grp_hist)]])){
grp_hist[[i]][[j]]$grp_sol <- j
}
grp_hist[[i]][[j]]
})
})
prune <- unlist(lapply(grp,"[","n_group_paths")) != 0
if (any(prune)){
grp_prune <- lapply(seq_along(grp), function(i){
if(ms_allow){
writeLines(paste0("solution ", i ,"..."))
}
prune.paths(
base_syntax    = dat$syntax,
fixed_syntax   = NULL,
add_syntax     = grp[[i]]$group_paths,
data_list      = dat$ts_list,
n_paths        = grp[[i]]$n_group_paths,
n_subj         = dat$n_subj,
prop_cutoff    = dat$group_cutoff,
elig_paths     = grp$group_paths,
subgroup_stage = FALSE
)
})
# #-----------------------------------------------------------#
# # Add the pruning information to the grp history.
# Note: the group history does not contain "accurate"
#       accounting of the model state, as pruned paths
#       are indicated in the pruned field of the final
#       entry of a given stage.
# #-----------------------------------------------------------#
grp_hist[[length(grp_hist)]] <- lapply(seq_along(grp_hist[[length(grp_hist)]]), function(i){
pruned <- setdiff(grp[[i]]$group_paths, grp_prune[[i]]$add_syntax)
if(length(pruned) != 0){
grp_hist[[length(grp_hist)]][[i]]$pruned <- pruned
}
grp_hist[[length(grp_hist)]][[i]]
})
#-----------------------------------------------------------#
# Now, update the grp object to reflect the pruning.
#-----------------------------------------------------------#
grp <- lapply(seq_along(grp), function(i){
grp[[i]][["n_group_paths"]] <- grp_prune[[i]]$n_paths
grp[[i]][["group_paths"  ]] <- grp_prune[[i]]$add_syntax
grp[[i]]
})
} # end pruning
if (subgroup){
sub_res <- lapply(seq_along(grp), function(i){
res <- subgroupStage(
dat,
grp[[i]],
confirm_subgroup,
sub_feature,
ms_tol   = ms_tol,
ms_allow = FALSE
)
})
#-------------------------------------------------------------#
# Break up the results from subgrouping.
#-------------------------------------------------------------#
sub      <- lapply(sub_res, "[[", "sub")
sub_spec <- lapply(sub_res, "[[", "sub_spec")
ind      <- lapply(sub_res, "[[", "ind")
grp_sub  <- lapply(sub_res, "[[", "grp")
#-------------------------------------------------------------#
# Expand the grp_history object to contain subgroup solutions.
#-------------------------------------------------------------#
sub_hist  <- list(); cnt<-1
for(i in 1:length(grp)){
sub_pruned_grp_paths <- setdiff(grp[[i]]$group_paths, grp_sub[[i]]$group_paths)
grp_level_paths      <- grp_hist[[length(grp_hist)]][[i]]$add_syntax
grp_level_n_paths    <- grp_hist[[length(grp_hist)]][[i]]$n_paths
for(j in 1:sub[[i]]$n_subgroups){
sol_i_subgrp_j_hist            <- grp_hist[[length(grp_hist)]][[i]]
sol_i_subgrp_j_hist$add_syntax <- c(grp_level_paths, sub_spec[[i]][[j]]$sub_paths)
sol_i_subgrp_j_hist$n_paths    <- grp_level_n_paths + sub_spec[[i]][[j]]$n_sub_paths
sol_i_subgrp_j_hist$pruned     <- sub_pruned_grp_paths
sol_i_subgrp_j_hist$stage      <- "subgroup"
sol_i_subgrp_j_hist$grp_sol    <- i
sol_i_subgrp_j_hist$sub_sol    <- j
sol_i_subgrp_j_hist$ind_sol    <- NA
sub_hist[[cnt]] <- sol_i_subgrp_j_hist
cnt <- cnt + 1
}
}
hist <- append(grp_hist, grp_hist[length(grp_hist)])
hist[[length(hist)]] <- sub_hist
#-------------------------------------------------------------#
# Update the grp object in case grp paths were pruned
#-------------------------------------------------------------#
grp <- grp_sub
} else {
sub      <- NULL
sub_spec <- NULL
ind      <- dat$file_order
hist     <- grp_hist
}
if(!ms_allow){
# individual-level search # ind <- ind[1]; grp <- grp[[1]]
store <- indiv.search(dat, grp[[1]], ind[1])
if(!is.null(lv_model)){
dat$lvgimme$miiv_est_table <- fitFinalGimmeModels(
ts_list_obs = dat$lvgimme$ts_list_obs,
meas_model  = dat$lvgimme$model_list_dfa,
lv_model    = lapply(store$syntax, function(x){x[!grepl("0\\*", x)]}),
miiv.dir    = file.path(dat$out,"miiv"),
lv_final_estimator = lv_final_estimator
)
}
print.gimme(x = sub[[1]],
y = subgroup,
z = dat)
# wrap-up and create output
final <- final.org(dat,
grp = grp[[1]],
sub = sub[[1]],
sub_spec = sub_spec[[1]],
diagnos = diagnos,
store)
# these objects are used in print.gimmep
# if you change an object name here,
# you need to change it in the print.gimmep.R
res <- list(data            = dat$ts_list,
path_est_mats   = store$betas,
varnames        = dat$varnames,
n_vars_total    = dat$n_vars_total,
n_lagged        = dat$n_lagged,
n_endog         = dat$n_endog,
fit             = final$fit,
path_se_est     = final$param_est,
plots           = store$plots,
group_plot      = final$samp_plot,
sub_plots       = final$sub_plots,
subgroup        = subgroup,
path_counts     = final$sample_counts,
path_counts_sub = final$sub_counts,
vcov            = store$vcov,
vcovfull        = store$vcovfull,
sim_matrix      = sub[[1]]$sim,
syntax          = dat$syntax,
lvgimme         = dat$lvgimme
)
class(res) <- "gimmep"
invisible(res)
} else {
#-----------------------------------------------#
# GIMME-MS: Individual level search             #
#-----------------------------------------------#
ind_results <- lapply(seq_along(grp), function(j){
if(ms_allow){
writeLines(paste0("group solution ", j ,"..."))
}
if(subgroup){
indiv.search.ms(dat, grp[[j]], ind[[j]], ms_tol, ms_allow, j)
} else {
indiv.search.ms(dat, grp[[j]], ind, ms_tol, ms_allow, j)
}
})
ind_hist <- lapply(ind_results, "[[", "ind_history")
ind_fit  <- lapply(ind_results, "[[", "res")
writeLines("gimme multiple solutions finished running normally")
res <- list(
dat = dat,
grp = grp,
ind = ind,
sub = sub,
sub_spec = sub_spec,
grp_hist = hist,
ind_hist = ind_hist,
ind_fit  = ind_fit
)
class(res) <- "gimmemsp"
# write gimme ms results to csv file
res$tables <- gimmems.write(res)
invisible(res)
}
exogenous
library(gimme)
gimmeSEM(data = '/Users/gateslab/Desktop/data_lgoetschius',
out = '/Users/gateslab/Desktop/AB_out',
sep = '',
header = FALSE,
ar = TRUE,
plot = TRUE,
sub_feature = "lag & contemp",
subgroup = TRUE,
confirm_subgroup = NULL,
paths = NULL,
exogenous = NULL,
conv_vars = NULL,
conv_length = 16,
conv_interval = 1,
mult_vars = NULL,
mean_center_mult = FALSE,
standardize = TRUE,
groupcutoff = .75,
subcutoff = .25,
diagnos = FALSE)
